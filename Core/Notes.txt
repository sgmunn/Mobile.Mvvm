
- injection scopes need to have parent scopes so that you can get the injected value of an object regardless of where that value was added.

- need a mechanism to bind a button to a command

- binding parser, like mvvm cross or ko
    - focus on being able to do the standard stuff + converters
    - the delegate property accessors are really only need for really complex and performant binding, reflection otherwise is fine
    - <TargetPropertyPath> <modeExpression> <sourcePropertyExpression>
    
     <TargetPropertyPath> = name
                            name.child ...
                            name[index] .. for indexed list propeties
                            
    <modeExpression>        >  |  <  | :   
    
    <sourcePropertyExpression>
                            <propertyPath> | <converterFunction>
                            
    <converterFunction>
                            <converterFunctionName> (  <propertyPath> , <convertParam>  )     
                            
    <propertyPath>
                            [ $parent.<path> ] | [ $root.<path> ] |  <path>                                                                 
        

- ko has $parent, $root etc for binding scope, we should allow the same thing
    - our binding scope gives us a way of grouping bindings together for lifetime management purposes
    - for this to work, we need a way to link view models in a parent - child chain

- need to support more complex property paths, eg TextLabel.Text

- need to support having bindings in the view axml for android, as this will be the preferred mechanism

- for iOS, we need to have either strong bindings or create our own stubb classes
    not sure of the best way to go, on the face of it, a simple wrapper for UITableViewCell would probably do
    the reason is that UITableViewCell, being a "built in" UIxxx control, gets GC'd before the iOS native 
    object and is re-instantiated whenever it needs to be. Because we have weak references everywhere
    our bindings get broken. Stron references fix that, but we have to clean up properly.
    If we have a wrapper class, our managed object stays around for as long as the native object exists
    
    I might just go for the wrapper classes as it will give the basis of the dialog style views




